## 一条SQL语句执行得很慢的原因有哪些？
### 1、大多数情况下是正常的，只是偶尔出现很慢的情况
    针对于偶尔很慢的情况下：
        （1）数据库再刷新脏页
            我们在向数据库插入数据和更新数据时，内存把对应的字段是数据进行更新，更新的数据不会马上同步持久化到硬盘中，
            是把这更新的记录写入到redo log日志中，空闲时通过redo log日记记录的新数据同步到磁盘中但是redo log里的容量
            有限，如果数据库更新和使用频繁会导致redo log写满，就不能在空闲时间把数据同步到磁盘中，所以只能暂停其他操
            作等待把数据同步到磁盘中，所以就会导致SQL语句执行速度会变慢
            
            脏页：linux内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，
            以提高读写速度，这就叫高速缓存，linux是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被
            内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的
            redo log日志主要作用：脏页与磁盘数据存在差异，那么如果这期间数据库出现故障就会造成数据的丢失，为了解决这个
            问题，就用到了redo log redo log在数据库重启恢复的时候被使用，因为其属于物理日志的特性，恢复速度远快于逻辑
            日志。而我们经常使用的binlog就属于典型的逻辑日志
            
        （2）数据库中某表或某一行含有锁
              我们在执行语句中可能会链接到其他的表，别人也在使用这个表并且加了锁，这个时候只能等待别人使用完这个表，
              并且释放这个所才能够使用，同样某行可能也含有锁，同时也需要等待如果要判断是否真的在等待锁，
              可以用show processlist这个命令进行查询当时的状态
                   
    2、在数据量不变情况下，这条SQL语句一直以来执行的很慢
        假设有一张表
            CREATE TABLE `t` (
            `id` int(11) NOT NULL,
            `c` int(11) DEFAULT NULL,
             d` int(11) DEFAULT NULL,
             PRIMARY KEY (`id`)
             ) ENGINE=InnoDB;
         （1）字段没有索引
            如果在进行查询某一个字段时，这个字段没有加索引，只能通过扫描全表，所以整体的时间就会变慢
         （2）字段有索引但是没有用到索引
            例如：select * from table where c - 1 =100
            例子中就没有用到索引，而是左边进行了运算，系统中不会不会自动优化成 c=100+1，这个也算是在书写语句时的一个
            疏忽，正确的书写格式应该是下方：
            正确格式：select * from table where c=100+1
         （3）函数操作导致没有用到索引
             我们在进行查询时，对字段进行了函数操作
             例如：select * from table where pow(c,2)=100
             这样的操作也是先进行运算在进行查找，索引没有用上字段上的索引，同时语句执行的速度会减慢
         （4）数据库选错索引
             主键索引和非主键索引是有区别的，主键索引存放的值是整行字段的数据，而非主键索引存放值不是整行字段的数据，而是
             存放的是主键字段的值。系统在执行语句的时候会进行预测，看看扫描某个字段的行数少还是直接扫描全表的行数少。系统
             是通过索引的区分度来进行判断，一个索引上的值越多，意味着出现相同数值的索引就越少，意味着索引区分度越高，我们
             也把区分度称之为基数，即区分度越高，基数越大，所以一个字段的索引奇数越大，意味着走索引查询越有优势。然系统不
             会遍历全部来获得一个索引的基数，所以通过采样的方式来进行预测。当然采样就一样会出现失误的情况，所以就会导致索
             引基数会变小，导致系统没有走索引，而是进行扫描全表，这样来进行语句执行时速度会变慢我们可以通过强制走索引的方
             式来进行查询
             例如：select * from table force index(a) where c<10 and c<100
             也可以：show index from t
             来查询索引的基数和实际是否符合，如果和实际很不符，我们可以进行重新统计索引的基数
             analyze table t